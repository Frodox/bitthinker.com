<!--
Title: Как вернуть значение из bash функции?
Description: Как вернуть значение из bash функции
Author: Cristian Evans
Date: 2013/10/08
Tags: bash, development
-->

Как известно, в `bash` все функции и команды возвращаю лишь код возврата
(ноль - успешное завершение, не-ноль - ошибка).
Для того, чтобы вернуть нечто отличное от числа,
нужно использовать один из следующих приёмов:

* установка глобальной переменной
* использование подстановки (чтение вывода команды)
* передача косвенной ссылки в функцию

Рассмотрим подробнее, как же использовать данные подходы<!--cut-here-->.

---

## Установка глобальной переменной

Что может быть проще, чем загадить глобальную область видимости в функции,
и затем считать из неё данные в основной программе?

    function makedirty()
    {
        myresult='oh, sic...!'
    }
    
    makedirty
    echo $myresult  # oh, sic...!

Оно и понятно, ведь все переменные в `bash` по-умолчанию - глобальные.  

    + Элементарно реализуется
    + Возможность вернуть несколько значений
    - В больших программах может привести к трудноуловимым ошибкам
    -   т.к. кто-то случайно где-то может затереть Вашу переменную

---
## Иcпользование подстановки, aka $(function)

Довольно распространённый механизм. Вы уже, наверняка, сами не зная того,
неоднократно им пользовались. Идея в том, что мы сохраняем в переменную всё,
что выводит некая команда (функция -- тоже команда).
Ну и конечно, что бы без необходимости не засорять глобальную область видимости,
рекомендуется использовать локальные переменные.


    function makecoffe()
    {
        local  myresult='done done done!'
        echo "$myresult"
    }

    result=$(makecoffe)   # или result=`myfunc`
    echo $result          # done done done!

<pre><code class="diff">+ Не засоряется глобальная область видимости
- Можно вернуть лишь 1 значение (или несколько разделённых неким разделителем)
</code></pre>

---

## Передача косвенной ссылки (Indirect References) в функцию

Самый интересный, функциональный и неуклюжий механизм :)  
Это проще 1 раз увидеть, чем 100 раз услышать:

    #!/bin/bash
    # return-val-func-3.sh: Передача косвенной ссылки в функцию.

    echo_var ()
    {
        echo "$1"
    }

    message=Hello
    Hello=Goodbye

    echo_var "$message"        # Hello
    # Теперь давайте передадим в функцию косвенную ссылку.
    # Т.е. дважды разыменуем переменную message
    echo_var "${!message}"     # Goodbye

    echo "-------------"

    # И что же произойдёт, если мы поменяем содержимое переменной "Hello" ?
    Hello="Hello, again!"
    echo_var "$message"        # Hello
    echo_var "${!message}"     # Hello, again!

    exit 0

### А теперь по-честному и по порядку

В отличии от некоторых других языков программирования, в `bash`
сценариях параметры в функцию обычно передаются по значению.
Если имена переменных (которые фактически являются _указателями_)
будут переданы в функцию в качестве параметров, то они будут обработаны,
как строковые литералы.  
_Функции обрабатывают свои аргументы, как литералы._


_Переменные_ - это способ представления данных в различных языках программирования.
 Переменная не более чем метка - имя, назначенное области или
 группе областей памяти компьютера, где содержатся данные.

_Имя_ переменной - это "контейнер" для хранения _значения_ данных.
Обращение к значению (получение значения) переменной называется _подстановкой переменной_.

Отмечу, что надо различать _имя_ переменной и ее _значение_.
Если __variable1__ - имя переменной, то __$variable1__ - обращение к _значению_,
 которое она содержит.

_Имя_ переменной - в действительности, ссылка/указатель на область(ти) памяти,
 где фактические данные связаны со значением, которое они хранят.

    bash$ variable1=23
    bash$ echo variable1
    variable1
    bash$ echo $variable1
    23

Как сказано выше, после подстановки переменной (_referencing a variable_, `$var`),
мы получаем _значение_, на которую указывает переменная.
А как насчёт _значения, на которое укзывает само значение_? `$$var` ?
Вы же помните, что с переменными мы работаем просто как с литералами? :)
Ну вот мы и пробуем получить значение, на которое указывает переменная,
имя которой тоже является значением другой переменной.
Немного запутанно, но, надеюсь, уловили.

Настоящая нотация выглядит как `\$$var` (или, c версии `bash 2`, как `${!variable}`)
и обычно используется вместе с `eval`.
Данный механизм и называется _косвенная ссылка_ (_indirect reference_).

### Пример 1. Для понимания

    #!/bin/bash
    # dereference.sh
    # Разыменовывание параметра переданного в функцию.
    # Сценарий от Bruce W. Clare.

    dereference ()
    {
         y=\$"$1"   # Сохранили имя переменной
         echo $y    # $Junk     == echo \$$y

         x=`eval "expr \"$y\" "`    # $x == Junk
         echo $1=$x
         eval "$1=\"Некоторый Другой Текст \""  # Присваиваем новое значение.
    }

    Junk="Некоторый Текст"
    echo $Junk "до"         # Некоторый Текст до

    dereference Junk
    echo $Junk "после"     # Некоторый Другой Текст после

    exit 0

### Пример 2. Практичный

    function myfunc()
    {
        local  __resultvar=$1
        local  myresult='some value'
        eval $__resultvar="'$myresult'"
    }

    myfunc result
    echo $result

Так как имя переменной само хранится в переменной,
мы не можем установить его напрямую. Для этого используют `eval`.
Если в кратце, `eval` сообщает `bash`-интерпретатору, что необходимо
дважды проинтерпретировать строку. В первый раз он установит `result='some value'`,
а во второй - искомую переменную (которую передали как аргумент).

При сохранении имени переменной, которую передали как аргумент командной строки,
убедитесь, что сохраняете её локально и в переменную с отличным (по возможности)
именем, нежели использовалась в командной строке. Если этого не сделать,
и имя переменной, переданной как параметр командной строки, совпадёт с именем
локальной переменной, в которую Вы сохраняете значение, то ничего не будет работать :D  

### Пример 3. Не работающий!

    function myfunc()
    {
        local  result=$1
        local  myresult='some value'
        eval $result="'$myresult'"
    }

    myfunc result
    echo $result

Почему? Ну... в тот момент когда `eval` совершает вторую подстановку в
`result='some value'`, `result` - уже локальная переменная функции, поэтому
мы установим _её_ ещё разок, а не искомую переменную.

Для большей гибкости, можно комбинировать разные подходы:

### Пример 4. Универсальный

    function myfunc()
    {
        local  __resultvar=$1
        local  myresult='some value'
        if [[ "$__resultvar" ]]; then
            eval $__resultvar="'$myresult'"
        else
            echo "$myresult"
        fi
    }
    
    myfunc result
    echo $result        # some value
    result2=$(myfunc)
    echo $result2       # some value

Т.е. если в функцию не передано ни одного параметра, значение просто выводится в `stdout`.

---
Использованные источники:

* Linux Journal: [Returning Values from Bash Functions](http://www.linuxjournal.com/content/return-values-bash-functions)
* Advanced Bash Scripting по-русски [4. Введение в переменные и параметры] [3], [9. Indirect References] [2], [23. Функции] [1]

[1]: http://www.bash-scripting.ru/abs/chunks/ch23.html
[2]: http://www.bash-scripting.ru/abs/chunks/ch09s05.html
[3]: http://www.bash-scripting.ru/abs/chunks/ch04.html
